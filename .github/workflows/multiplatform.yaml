name: Manually triggered build of multiplatform test container

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'EUPS tag of input DM Pipelines Stack container'
        required: true
        default: ''
      supplementary:
        description: 'Supplementary tag for experimental builds; yields output tag exp_tag_supplementary'
        required: false
        default: ''
      image:
        description: 'fully-qualified URI for output Docker image'
        required: false
        default: 'us-central1-docker.pkg.dev/rubin-shared-services-71ec/sciplat/multi-test,ghcr.io/lsst-sqre/multi-test,docker.io/lsstsqre/multi-test'
      input:
        description: 'input image; you probably should change at most the tag'
        required: false
        default: 'docker.io/library/alpine:latest'

# We need actions/write if we want to do a GH App, and we need
# packages/write to push to ghcr.io with GITHUB_TOKEN
permissions:
  actions: write
  contents: read
  packages: write
  statuses: read

jobs:
  multiplatform_setup:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      version: ${{ steps.calculate_version.outputs.version }}
    env:
      tag: ${{ github.event.inputs.tag }}
      supplementary: ${{ github.event.inputs.supplementary }}
      image: ${{ github.event.inputs.image }}
      input: ${{ github.event.inputs.input }}

    steps:
    - name: checkout_setup
      uses: actions/checkout@v4

    - name: calculate_version
      id: calculate_version
      shell: bash
      run: |
        . scripts/functions.sh
        version=$(tag_to_version)
        echo "version=${version}" >> "${GITHUB_OUTPUT}"

  build_containers:
    needs: multiplatform_setup
    runs-on: ubuntu-latest
    timeout-minutes: 300
    outputs:
      version: ${{ needs.multiplatform_setup.outputs.version }}
    env:
      version: ${{ needs.multiplatform_setup.outputs.version }}
      tag: ${{ github.event.inputs.tag }}
      image: ${{ github.event.inputs.image }}
      input: ${{ github.event.inputs.input }}
      supplementary: ${{ github.event.inputs.supplementary }}

    strategy:
      matrix:
        platform:
          - arch: "amd64"
          - arch: "arm64"
    steps:

    - name: checkout_setup
      uses: actions/checkout@v4

    - name: parse_env
      id: parse_env
      shell: bash
      run: |
         # env.image may be a comma-separated list of images; we are
         # thus creating a set of registry-specific variables from the
         # images in the list
         split_images=$(echo ${{ env.image }} | tr ',' ' ')
         for img in ${split_images}; do
             image_host=$(echo ${img} | cut -d '/' -f 1)
             # Check for implicit Docker Hub
             case ${image_host} in
                 *.*)
                     ;;
                 *)
                     image_host="docker.io"
                     ;;
             esac
             case ${image_host} in
                 docker.com | docker.io | *.docker.com | *.docker.io)
                     d_tag="docker_"
                     d_registry="docker.io"
                     d_username="${{ secrets.DOCKER_USERNAME }}"
                     d_password="${{ secrets.DOCKER_TOKEN }}"
                     ;;
                 ghcr.io | *.ghcr.io)
                     d_tag="github_"
                     d_registry="ghcr.io"
                     # using secrets.GITHUB_TOKEN fails, saying it doesn't
                     # have write.package, which seems weird.
                     d_username="token"
                     d_password="${{ secrets.GHCR_PUSH_TOKEN}}"
                     ;;
                 *-docker.pkg.dev)
                    d_tag="google_"
                    d_registry="${image_host}"
                    d_username="_json_key_base64"
                    d_password="${{ secrets.GAR_PUSH_TOKEN }}"
                    ;;
                 *)
                     d_tag=""
                     d_registry="${image_host}"
                     d_username=""
                     d_password=""
                     ;;
             esac
             echo "${d_tag}registry=${d_registry}" >> "$GITHUB_ENV"
             echo "${d_tag}username=${d_username}" >> "$GITHUB_ENV"
             echo "${d_tag}password=${d_password}" >> "$GITHUB_ENV"
         done

    # Only bother logging in to a given site if we have credentials
    - name: Log in to Docker Hub repository
      if: >-
        ((env.docker_registry != '') &&
         (env.docker_username != '') &&
         (env.docker_password != ''))
      uses: docker/login-action@v3
      with:
        registry: ${{ env.docker_registry }}
        username: ${{ env.docker_username }}
        password: ${{ env.docker_password }}

    - name: Log in to GitHub Container Registry
      if: >-
        ((env.github_registry != '') &&
         (env.github_username != '') &&
         (env.github_password != ''))
      uses: docker/login-action@v3
      with:
        registry: ${{ env.github_registry }}
        username: ${{ env.github_username }}
        password: ${{ env.github_password }}

    - name: Log in to Google Artifact Registry
      if: >-
        ((env.google_registry != '') &&
         (env.google_username != '') &&
         (env.google_password != ''))
      uses: docker/login-action@v3
      with:
        registry: ${{ env.google_registry }}
        username: ${{ env.google_username }}
        password: ${{ env.google_password }}

    - name: setup_buildx
      uses: docker/setup-buildx-action@v3
      with:
        name: multi-test-${{ matrix.platform.arch }}
        platforms: linux/${{ matrix.platform.arch }}

    - name: calculate_tags
      id: calculate_tags
      shell: bash
      env:
        platform: ${{ matrix.platform.arch }}
      run: |
        . scripts/functions.sh
        tags=$(calculate_tags)
        echo "tags=${tags}" >> "${GITHUB_OUTPUT}"
        echo "platform=${platform}" >> "${GITHUB_OUTPUT}"

    - name: build_platform_container
      uses: docker/build-push-action@v6
      with:
        builder: multi-test-${{ matrix.platform.arch }}
        platforms: linux/${{ matrix.platform.arch }}
        tags: ${{ steps.calculate_tags.outputs.tags }}
        push: true
        build-args: |
          input=${{ github.event.inputs.input }}
          tag=${{ github.event.inputs.tag }}
          version=${{ env.version }}
          image=${{ github.event.inputs.image }}
          supplementary=${{ github.event.inputs.supplementary }}
          cache-from=type=gha
          cache-to=type=gha,mode=max

  unify_manifest:
    needs: build_containers
    runs-on: ubuntu-latest
    env:
      version: ${{ needs.build_containers.outputs.version }}
      tag: ${{ github.event.inputs.tag }}
      image: ${{ github.event.inputs.image }}
      input: ${{ github.event.inputs.input }}
      supplementary: ${{ github.event.inputs.supplementary }}
    timeout-minutes: 30

    steps:
      - name: checkout_unify_manifest
        uses: actions/checkout@v4

      - name: parse_env
        id: parse_env
        shell: bash
        run: |
           # env.image may be a comma-separated list of images; we are
           # thus creating a set of registry-specific variables from the
           # images in the list
           split_images=$(echo ${{ env.image }} | tr ',' ' ')
           for img in ${split_images}; do
               image_host=$(echo ${img} | cut -d '/' -f 1)
               # Check for implicit Docker Hub
               case ${image_host} in
                   *.*)
                       ;;
                   *)
                       image_host="docker.io"
                       ;;
               esac
               case ${image_host} in
                   docker.com | docker.io | *.docker.com | *.docker.io)
                       d_tag="docker_"
                       d_registry="docker.io"
                       d_username="${{ secrets.DOCKER_USERNAME }}"
                       d_password="${{ secrets.DOCKER_TOKEN }}"
                       ;;
                   ghcr.io | *.ghcr.io)
                       d_tag="github_"
                       d_registry="ghcr.io"
                       # using secrets.GITHUB_TOKEN fails, saying it doesn't
                       # have write.package, which seems weird.
                       d_username="token"
                       d_password="${{ secrets.GHCR_PUSH_TOKEN}}"
                       ;;
                   *-docker.pkg.dev)
                      d_tag="google_"
                      d_registry="${image_host}"
                      d_username="_json_key_base64"
                      d_password="${{ secrets.GAR_PUSH_TOKEN }}"
                      ;;
                   *)
                       d_tag=""
                       d_registry="${image_host}"
                       d_username=""
                       d_password=""
                       ;;
               esac
               echo "${d_tag}registry=${d_registry}" >> "$GITHUB_ENV"
               echo "${d_tag}username=${d_username}" >> "$GITHUB_ENV"
               echo "${d_tag}password=${d_password}" >> "$GITHUB_ENV"
           done

      # Only bother logging in to a given site if we have credentials
      - name: Log in to Docker Hub repository
        if: >-
          ((env.docker_registry != '') &&
           (env.docker_username != '') &&
           (env.docker_password != ''))
        uses: docker/login-action@v3
        with:
          registry: ${{ env.docker_registry }}
          username: ${{ env.docker_username }}
          password: ${{ env.docker_password }}

      - name: Log in to GitHub Container Registry
        if: >-
          ((env.github_registry != '') &&
           (env.github_username != '') &&
           (env.github_password != ''))
        uses: docker/login-action@v3
        with:
          registry: ${{ env.github_registry }}
          username: ${{ env.github_username }}
          password: ${{ env.github_password }}

      - name: Log in to Google Artifact Registry
        if: >-
          ((env.google_registry != '') &&
           (env.google_username != '') &&
           (env.google_password != ''))
        uses: docker/login-action@v3
        with:
          registry: ${{ env.google_registry }}
          username: ${{ env.google_username }}
          password: ${{ env.google_password }}

      - name: make_total_tagset
        id: make_total_tagset
        shell: bash
        run: |
          . scripts/functions.sh
          export version=$(tag_to_version)
          t1=$( platform=amd64 calculate_tags )
          t2=$( platform=arm64 calculate_tags )
          in="${t1},${t2}"
          out="$(echo ${t1} | sed -e 's/-amd64,/,/g' -e 's/-amd64$//g' )"
          echo "in=${in}" >> "${GITHUB_OUTPUT}"
          echo "out=${out}" >> "${GITHUB_OUTPUT}"
          echo 'in_cr<<EOF' >> ${GITHUB_OUTPUT}
          echo ${in} | tr ',' '\n' >> ${GITHUB_OUTPUT}
          echo 'EOF' >> ${GITHUB_OUTPUT}
          echo "out_cr<<EOF" >> ${GITHUB_OUTPUT}
          echo ${out} | tr ',' '\n' >> ${GITHUB_OUTPUT}
          echo "EOF" >> ${GITHUB_OUTPUT}          

      - name: show_tagsets
        env:
          in: ${{ steps.make_total_tagset.outputs.in }}
          out: ${{ steps.make_total_tagset.outputs.out }}
          in_cr: ${{ steps.make_total_tagset.outputs.in_cr }}
          out_cr: ${{ steps.make_total_tagset.outputs.out_cr }}
        shell: bash
        run: |
          echo "IN TAGSET: ${in}"
          echo "OUT TAGSET: ${out}"
          echo "IN TAGSET (CR): ${in_cr}"
          echo "OUT TAGSET (CR): ${out_cr}"

      # - name: make_manifest
      #   uses: int128/docker-manifest-create-action@v2
      #   with:
      #     tags: |
      #       ${{ steps.make_total_tagset.outputs.out_cr }}
      #     sources: |
      #       ${{ steps.make_total_tagset.outputs.in_cr }}
      #     push: true

      # - name: split_tags_by_registry
      #   env:
      #     tagset_in: ${{ steps.make_total_tagset.outputs.in }}
      #     tagset_out: ${{ steps.make_total_tagset.outputs.out }} 
      #   shell: bash
      #   run: |
      #     . scripts/functions.sh
      #     ghcr_tags_in=$( filter_tags ghcr.io ${tagset_in} )
      #     gar_tags_in=$( filter_tags us-central1-docker.pkg.dev ${tagset_in} )
      #     docker_tags_in=$( filter_tags docker.io ${tagset_in} )
      #     ghcr_tags_out=$( filter_tags ghcr.io ${tagset_out} )
      #     gar_tags_out=$( filter_tags us-central1-docker.pkg.dev ${tagset_out} )
      #     docker_tags_out=$( filter_tags docker.io ${tagset_out} )
      #     echo "ghcr_tags_in=${ghcr_tags_in}" >> ${GITHUB_ENV}
      #     echo "gar_tags_in=${gar_tags_in}" >> ${GITHUB_ENV}
      #     echo "docker_tags_in=${docker_tags_in}" >> ${GITHUB_ENV}
      #     echo "ghcr_tags_out=${ghcr_tags_out}" >> ${GITHUB_ENV}
      #     echo "gar_tags_out=${gar_tags_out}" >> ${GITHUB_ENV}
      #     echo "docker_tags_out=${docker_tags_out}" >> ${GITHUB_ENV}

      # - name: manifest_for_ghcr
      #   if: >-
      #     (( ${ env.ghcr_tags_in }} != '' ) &&
      #     ( ${{ env.ghcr_tags_out }} != '' )
      #   uses: Noelware/docker-manifest-action@v1
      #   with:
      #     inputs: ${{ env.ghcr_tags_in }}
      #     tags: ${{ env.ghcr_tags_out }}
      #     push: true
          
      # - name: manifest_for_gar
      #   if: >-
      #     (( ${{ env.gar_tags_in }} != '' ) &&
      #     ( ${{ env.gar_tags_out }} != '' ))
      #   uses: Noelware/docker-manifest-action@v1
      #   with:
      #     inputs: ${{ env.gar_tags_in }}
      #     tags: ${{ env.gar_tags_out }}
      #     push: true
          
      # - name: manifest_for_docker
      #   if: >-
      #     (( ${{ env.docker_tags_in }} != '' ) &&
      #     ( ${ env.docker_tags_out }} != '' ))
      #   uses: Noelware/docker-manifest-action@v1
      #   with:
      #     inputs: ${{ env.docker_tags_in }}
      #     tags: ${{ env.docker_tags_out }}
      #     push: true

      - name: manifest_for_docker
        uses: Noelware/docker-manifest-action@v1
        with:
          inputs: ${{ steps.make_total_tagset.outputs.in }}
          tags: ${{ steps.make_total_tagset.outputs.out }}
          push: true
